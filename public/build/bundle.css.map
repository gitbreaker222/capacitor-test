{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../Playlist.svelte",
    "../../VirtualList.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport { onMount, afterUpdate, onDestroy } from 'svelte';\n\timport {\n\t\tplayerStore,\n\t\tplayPause, \n\t\tplay,\n\t\tplayPrev,\n\t\tplayNext,\n\t\ttoggleRandom,\n\t\tsetFilterText,\n\t} from './playerStore.js'\n\timport Playlist from './Playlist.svelte'\n\timport { debounce, sortByIndexId } from './utils.js'\n\t\n\t// constants / variables / state\n\tlet audio\t\n\t$: paused = $playerStore.paused\n  $: isRandom = $playerStore.isRandom\n\t$: previous = $playerStore.previous \n\t$: current = $playerStore.current\n\t$: next = $playerStore.next\n\t$: nextPrev = $playerStore.nextPrev\n\t$: remaining = $playerStore.remaining\n\t\n\t// derived\n\t$: currentCounter = previous.length + (current ? 1 : 0)\n\t$: totalCount = currentCounter + next.length + nextPrev.length + remaining.length\n\t\n\t// event handler\n\tconst handleFilter = debounce(function (event) {\n\t\tsetFilterText(event.target.value)\n\t}, 700)\n\t\n\tconst handlePlay = () => {\n\t\tplayPause(true)\n\t}\n\tconst handlePause = (event) => {\n\t\tconst {\n\t\t\tcurrentTime,\n\t\t\tduration\n\t\t} = event.target\n\t\tif (currentTime === duration) playNext()\n\t\telse playPause(false)\n\t}\n\t\n</script>\n\n<svelte:head>\n\t<link rel=\"stylesheet\" href=\"//fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic\">\n\t<link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.css\">\n\t<link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/milligram/1.3.0/milligram.css\">\n</svelte:head> \n\n<div class=\"controls\" style=\"display: normal\">\n\t<button on:click={playPrev}><i>�</i> prev</button>\n\t<button on:click={playNext}>next <i>{isRandom ? '=':'�'}</i> </button>\n\t<label class=\"button\">\n\t\t<input type=\"checkbox\"\n\t\t\t\t\t checked={isRandom}\n\t\t\t\t\t on:click={toggleRandom}\n\t\t\t\t\t >\n\t\t<i>=</i>\n\t</label>\n\t<input class=\"search\"\n\t\t\t\t type=\"text\"\n\t\t\t\t placeholder=\"filter:\"\n\t\t\t\t on:input=\"{handleFilter}\">\n\t<div class=\"info\">\n\t\t{currentCounter}/{totalCount}&emsp;\n\t\t{#if current}<strong>{current.name}</strong>{/if}\n\t</div>\n\t<audio\n    autoplay\n\t\tcontrols\n\t\tsrc={current && current.src}\n\t\tbind:paused={paused}\n\t\ton:pause={handlePause}\n\t\ton:play={handlePlay}\n\t></audio>\n</div>\n\n<Playlist></Playlist>\n\n<style>\n\t:global(html body) {\n\t\tdisplay: flex;\n\t\tflex-flow: column-reverse nowrap;\n\t}\n\t:global(html ul, html li, html button) {margin: 0}\n\t:global(html button, .button) {padding: 0 1.5rem}\n\t:global(html i) {\n\t\tfont-style: normal;\n\t\tfont-size: 1.8rem;\n\t\tfont-weight: normal;\n\t}\n\tbutton {\n\t\tdisplay: inline-flex;\n\t\talign-items: center;\n\t}\n\t\n\t.controls {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\tz-index: 1;\n\t\tbackground: white;\n\t\tbox-shadow: 0 0 0.5em .5em white;\n\t}\n\t.controls .search {\n\t\tflex: 1 0 5rem;\n\t}\n\t.controls .search:focus {\n\t\tflex: 1 1 40rem;\n\t}\n\t.controls .info {\n\t\tflex: 1 0 100%;\n\t\tfont-size: 11px;\n\t}\n\taudio {\n\t\twidth: 100%;\n\t\theight: 2rem;\n\t}\n\t\n</style>\n",
    "\n<script>\n\timport { onMount, afterUpdate, tick } from 'svelte';\n\timport { flip } from 'svelte/animate';\n\timport { fade } from 'svelte/transition';\n\t//import VirtualList from '@sveltejs/svelte-virtual-list';\n\timport VirtualList from './VirtualList.svelte'\n\timport {\n\t\tplayerStore,\n\t\tplayPause, \n\t\tplay,\n\t\tqueueSong,\n\t\tresetSong,\n\t\tjumpTo,\n\t\tPLAYED,\n\t\tCURRENT,\n\t\tQUEUE,\n\t\tPREV_QUEUE,\n\t\tREMAINING,\n\t} from './playerStore.js'\n\timport { send, receive } from './utils.js'\n\timport { filterListByName, addType } from './utils.js'\n\t\n\t// Constants / Variables\t\n\tlet autoscroll = false\n\tlet scrollToIndex\n\t\n\t$: isPaused = $playerStore.paused\n\t$: isRandom = $playerStore.isRandom\n\t$: filterText = $playerStore.filterText\n\t$: previous = $playerStore.previous\n\t$: current = $playerStore.current\n\t$: next = $playerStore.next\n\t$: nextPrev = $playerStore.nextPrev\n\t$: remaining = $playerStore.remaining\n\t\n\t// Derived\n\t$: completeList = filterListByName([\n\t\t...previous.map(i => addType(i, PLAYED)),\n\t\taddType(current, CURRENT),\n\t\t...next.map(i => addType(i, QUEUE)),\n\t\t...nextPrev.map(i => addType(i, PREV_QUEUE)),\n\t\t...remaining.map(i => addType(i, REMAINING)),\n\t], filterText)\n\t\n\tfunction scrollToCurrent () {\n\t\tconst filterRemoved = !filterText\n\t\tif (autoscroll || filterRemoved) {\n\t\t\tlet index = completeList.indexOf(current)\n\t\t\tif (index > 0) index -= 1 //move current a bit to center\n\t\t\tscrollToIndex(index); \n\t\t}\n\t}\n\t\n\t// Event handler\n\tfunction handlePlay(event, song) {\n\t\tplay(song)\n\t\tautoscroll = true\n\t\twindow.getSelection().removeAllRanges()\n\t\t//audio.play()\n\t\t// TODO audio.autoplay = true\n\t}\n\t\n\tfunction handleDblClick (e, song) {jumpTo(song)}\n\t\n\tfunction handlePlayPause (event) {\n\t\tplayPause()\n\t}\n\t\n\t// Life cycle\n\tafterUpdate(function(x) {\n\t\tscrollToCurrent()\n\t})\n</script>\n\n<ul class=\"playlist\">\n\t<VirtualList items={completeList} let:item={song} bind:scrollToIndex>\n\t\t<li class=\"song {song.type}\"\n\t\t\t\ton:dblclick=\"{e => handleDblClick(e, song)}\"\n\t\t\t\t>\n\t\t\t<span class=\"status-icon\"></span>\n\t\t\t<span class=\"spacer\"></span>\n\t\t\t<span class=\"name\">{song.name}</span>\n\t\t\t<span class=\"spacer\"></span>\n\t\t\t{#if song.type === PLAYED}\n\t\t\t<button on:click=\"{e => queueSong(song, previous)}\">\n\t\t\t\t�+\n\t\t\t</button> \n\t\t\t{:else if song.type === CURRENT}\n\t\t\t<button on:click=\"{handlePlayPause}\">\n\t\t\t\t{#if isPaused}�{:else}�\u000f{/if}\n\t\t\t</button> \n\t\t\t{:else if song.type === QUEUE}\n\t\t\t<button on:click=\"{e => resetSong(song, next)}\">\n\t\t\t\t5\u000f\n\t\t\t</button> \n\t\t\t{:else if song.type === PREV_QUEUE}\n\t\t\t<button on:click=\"{e => resetSong(song, nextPrev)}\">\n\t\t\t\t5\u000f\n\t\t\t</button> \n\t\t\t{:else if song.type === REMAINING}\n\t\t\t<button on:click=\"{e => queueSong(song, remaining)}\">\n\t\t\t\t�+\n\t\t\t</button> \n\t\t\t{/if}\n\t\t</li>\n\t</VirtualList>\n</ul>\n\n<style>\n\t.spacer {\n\t\tmin-width: .6em;\n\t}\n\t\n\t.playlist {\n\t\tdisplay: flex;\n\t\tflex-flow: column;\n\t\tflex: 1;\n\t\toverflow: auto;\n\t\tdisplay: block;\n\t}\n\t\n\tli {\n\t\tpadding: .2em;\n\t\tborder-bottom: 1.1px solid currentColor;\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tposition: relative;\n\t\theight: 45px; /*important for exact virtual list*/\n\t\tline-height: 1;\n\t}\n\tli:active {\n\t\tbackground: #eee;\n\t}\n\t\n\tli .name {\n\t\tflex: 1;\n\t}\n\t\n\t.CURRENT {\n\t\t-border-top: 3px solid;\n\t\tfont-weight: bold;\n\t}\n\t\n\t.status-icon {\n\t\tmin-width: 1.2em;\n    text-align: center;\n\t}\n\t.CURRENT .status-icon:before {\n\t\tcontent: '�';\n\t}\n\t.PLAYED .status-icon:before,\n\t.QUEUE .status-icon:before,\n\t.PREV_QUEUE .status-icon:before {\n\t\tcontent: '+';\n\t}\n\t.PLAYED .status-icon:before {\n\t\tcontent: '�';\n\t}\n\t.PREV_QUEUE .status-icon:before {\n\t\tcontent: '#';\n\t}\n</style>\n\n<!-- regular list \n<ul class=\"playlist scrollable\" style=\"display: none\">\n\t{#each completeList as song (song.id)}\n\t\t<li class=\"song {song.type}\"\n\t\t\t\tin:receive=\"{{key: song.id}}\"\n\t\t\t\tout:send=\"{{key: song.id}}\"\n\t\t\t\tanimate:flip=\"{{duration: 200}}\"\n\t\t\t\ton:dblclick=\"{e => handleDblClick(e, song)}\"\n\t\t\t\t>\n\t\t\t<span class=\"status-icon\"></span>\n\t\t\t<span class=\"spacer\"></span>\n\t\t\t<span class=\"name\">{song.name}</span>\n\t\t\t<span class=\"spacer\"></span>\n\t\t\t{#if song.type === PLAYED}\n\t\t\t<button on:click=\"{e => queueSong(song, previous)}\">\n\t\t\t\t##\n\t\t\t</button> \n\t\t\t{:else if song.type === CURRENT}\n\t\t\t<button on:click=\"{e => (e)}\">\n\t\t\t\t{#if isPaused}�{:else}II{/if}\n\t\t\t</button> \n\t\t\t{:else if song.type === QUEUE}\n\t\t\t<button on:click=\"{e => resetSong(song, next)}\">\n\t\t\t\t5\u000f\n\t\t\t</button> \n\t\t\t{:else if song.type === PREV_QUEUE}\n\t\t\t<button on:click=\"{e => resetSong(song, nextPrev)}\">\n\t\t\t\t5\u000f\n\t\t\t</button> \n\t\t\t{:else if song.type === REMAINING}\n\t\t\t<button on:click=\"{e => queueSong(song, remaining)}\">\n\t\t\t\t+#\n\t\t\t</button> \n\t\t\t{/if}\n\t\t</li>\n\t{/each}\n</ul-->\n",
    "<script>\n\timport { onMount, tick } from 'svelte';\n\t// props\n\texport let items;\n\texport let height = '100%';\n\texport let itemHeight = undefined;\n\t// read-only, but visible to consumers via bind:start\n\texport let start = 0;\n\texport let end = 0;\n\texport const scrollToIndex = (...args) => _scrollTo(...args)\n\t// local state\n\tlet height_map = [];\n\tlet rows;\n\tlet viewport;\n\tlet contents;\n\tlet viewport_height = 0;\n\tlet visible;\n\tlet mounted;\n\tlet top = 0;\n\tlet bottom = 0;\n\tlet average_height;\n\tlet refreshReady;\n\t$: visible = items.slice(start, end).map((data, i) => {\n\t\treturn { index: i + start, data };\n\t});\n\t// whenever `items` changes, invalidate the current heightmap\n\t$: if (mounted) refresh(items, viewport_height, itemHeight);\n\t\n\tasync function refresh(items, viewport_height, itemHeight) {\n\t\tconst isStartOverflow = items.length < start\n\t\tif (isStartOverflow) {\n\t\t\tawait scrollToIndex(items.length - 1, {behavior: 'auto'})\n\t\t}\n\t\t\n\t\tlet resolveRefresh\n\t\trefreshReady = new Promise(resolve => {\n\t\t\tresolveRefresh = resolve\n\t\t})\n\t\t\n\t\tconst { scrollTop } = viewport;\n\t\tawait tick(); // wait until the DOM is up to date\n\t\tlet content_height = top - scrollTop;\n\t\tlet i = start;\n\t\t\n\t\twhile (content_height < viewport_height && i < items.length) {\n\t\t\tlet row = rows[i - start];\n\t\t\tif (!row) { \n\t\t\t\tend = i + 1;\n\t\t\t\tawait tick(); // render the newly visible row\n\t\t\t\trow = rows[i - start];\n\t\t\t}\n\t\t\tconst row_height = height_map[i] = itemHeight || row.offsetHeight;\n\t\t\tcontent_height += row_height;\n\t\t\ti += 1;\n\t\t}\n\t\tend = i;\n\t\tconst remaining = items.length - end;\n\t\taverage_height = (top + content_height) / end;\n\t\tbottom = remaining * average_height;\n\t\theight_map.length = items.length;\n\t\t\n\t\tresolveRefresh(true)\n\t}\n\t\n\tasync function handle_scroll() {\n\t\tconst { scrollTop } = viewport;\n\t\tconst old_start = start;\n\t\tfor (let v = 0; v < rows.length; v += 1) {\n\t\t\theight_map[start + v] = itemHeight || rows[v].offsetHeight;\n\t\t}\n\t\tlet i = 0;\n\t\tlet y = 0;\n\t\twhile (i < items.length) {\n\t\t\tconst row_height = height_map[i] || average_height;\n\t\t\tif (y + row_height > scrollTop) {\n\t\t\t\tstart = i;\n\t\t\t\ttop = y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ty += row_height;\n\t\t\ti += 1;\n\t\t}\n\t\twhile (i < items.length) {\n\t\t\ty += height_map[i] || average_height;\n\t\t\ti += 1;\n\t\t\tif (y > scrollTop + viewport_height) break;\n\t\t}\n\t\tend = i;\n\t\tconst remaining = items.length - end;\n\t\taverage_height = y / end;\n\t\twhile (i < items.length) height_map[i++] = average_height;\n\t\tbottom = remaining * average_height;\n\t}\n\t\n\tasync function _scrollTo (index, opts) {\n\t\tconst {scrollTop, scrollHeight} = viewport\n\t\tconst itemsDelta = index - start\n\t\tconst _itemHeight = itemHeight || average_height\n\t\tconst distance = itemsDelta * _itemHeight\n\t\t\n\t\topts = {\n\t\t\tleft: 0,\n\t\t\ttop: scrollTop + distance,\n\t\t\tbehavior: 'smooth',\n\t\t\t...opts\n\t\t}\n\t\tawait refreshReady;\n\t\tviewport.scrollTo(opts)\n\t}\n\t\n\t// trigger initial refresh\n\tonMount(() => {\n\t\trows = contents.getElementsByTagName('svelte-virtual-list-row');\n\t\tmounted = true;\n\t});\n</script>\n\n<style>\n\tsvelte-virtual-list-viewport {\n\t\tposition: relative;\n\t\toverflow-y: auto;\n\t\t-webkit-overflow-scrolling:touch;\n\t\tdisplay: block;\n\t}\n\tsvelte-virtual-list-contents, svelte-virtual-list-row {\n\t\tdisplay: block;\n\t}\n\tsvelte-virtual-list-row {\n\t\toverflow: hidden;\n\t}\n</style>\n\n<svelte-virtual-list-viewport\n\tbind:this={viewport}\n\tbind:offsetHeight={viewport_height}\n\ton:scroll={handle_scroll}\n\tstyle=\"height: {height};\"\n>\n\t<svelte-virtual-list-contents\n\t\tbind:this={contents}\n\t\tstyle=\"padding-top: {top}px; padding-bottom: {bottom}px;\"\n\t>\n\t\t{#each visible as row (row.index)}\n\t\t\t<svelte-virtual-list-row>\n\t\t\t\t<slot item={row.data}>Missing template</slot>\n\t\t\t</svelte-virtual-list-row>\n\t\t{/each}\n\t</svelte-virtual-list-contents>\n</svelte-virtual-list-viewport>"
  ],
  "names": [],
  "mappings": "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"
}